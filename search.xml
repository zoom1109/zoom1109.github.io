<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八数码 Eight</title>
    <url>/2018/07/16/%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h4 id="原题链接八数码-eight">原题链接：<a href="http://poj.org/problem?id=1077" target="_blank" rel="noopener">八数码 Eight</a></h4>
<h4 id="解题思路-a">解题思路 A*：</h4>
<p>​ 先进行可解性判定，把除空格之外的所有数字排成一个序列，求出该序列的逆序对数。如果初态和终态的逆序对数奇偶性相同，那么这两个状态互相可达，否则一定不可达。</p>
<p>​ 若问题有解，我们就采用 A * 算法搜索一种移动步数最少的方案。经过观察可以发现，每次移动只能把一个数字与空格交换位置，这样至多把一个数字向它在目标状态中的位置移近一步。即使每一步移动都是有意义的，从任何一个状态到目标状态的移动步数也不可能小于所有数字当前位置与目标位置的曼哈顿距离之和。</p>
<p>​ 于是，对于任意的状态state，我们可以把估计函数设定为：所有数字在state中的位置与目标状态End中位置的曼哈顿距离之和，即：</p>
<p>​ <span class="math inline">\(f(state) = \sum_{num=1}^9 {|statex_{num} - endx_{num}| + |statey_{num} - endy_{num}|}\)</span></p>
<p>​ 其中， <span class="math inline">\(statex_{num}\)</span> 表示在状态state下数字num的行号，<span class="math inline">\(statey_{num}\)</span> 为列号。</p>
<p>​ 我们不断从堆中取出”从初态到当前状态state已经移动的步数 + $f(state) $“ 最小进行扩展，当终态第一次被从堆中取出时，就得到了答案。</p>
<p>​ 在 A * 算法中，为了保证效率，每个状态只需要在第一次被取出时扩展一次。本题的状态是一个八数码，并非一个简单的节点编号，所以需要配合Hush来记录距离。</p>
<h4 id="代码如下">代码如下：</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; PIS;</span><br><span class="line"><span class="built_in">string</span> End = <span class="string">"12345678x"</span>;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">4</span>] = &#123;<span class="string">'u'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'l'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dis;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, pair&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &gt; pre;</span><br><span class="line">priority_queue&lt;PIS, <span class="built_in">vector</span>&lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">string</span> state)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(state[i] != <span class="string">'x'</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = state[i] - <span class="string">'1'</span>;</span><br><span class="line">			res += <span class="built_in">abs</span>(i/<span class="number">3</span> - t/<span class="number">3</span>) + <span class="built_in">abs</span>(i%<span class="number">3</span> - t%<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">bfs</span><span class="params">(<span class="built_in">string</span> start)</span></span>&#123;</span><br><span class="line">	heap.push(&#123;f(start), start&#125;);</span><br><span class="line">	dis[start] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(heap.size())&#123;</span><br><span class="line">		PIS  t = heap.top(); heap.pop();</span><br><span class="line">		<span class="built_in">string</span> state = t.y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(state == End)	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; state.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(state[i] == <span class="string">'x'</span>)&#123;</span><br><span class="line">                x = i/<span class="number">3</span>, y = i%<span class="number">3</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> backup = state;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx = x + dir[i][<span class="number">0</span>], ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">3</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">3</span>)	<span class="keyword">continue</span>;</span><br><span class="line">			state = backup;</span><br><span class="line">			swap(state[x*<span class="number">3</span> + y], state[tx*<span class="number">3</span> + ty]);</span><br><span class="line">			<span class="keyword">if</span>(dis.count(state) == <span class="number">0</span> || dis[state] &gt; dis[backup] + <span class="number">1</span>)&#123;</span><br><span class="line">				dis[state] = dis[backup] + <span class="number">1</span>;</span><br><span class="line">				pre[state] = &#123;op[i], backup&#125;;</span><br><span class="line">				heap.push(&#123;f(state) + dis[state], state&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> ans;</span><br><span class="line">	<span class="keyword">while</span>(start != End)&#123;</span><br><span class="line">		ans += pre[End].x;</span><br><span class="line">		End = pre[End].y;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(ans.begin(), ans.end());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> start, sec;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; c)&#123;</span><br><span class="line">		start += c;</span><br><span class="line">		<span class="keyword">if</span>(c != <span class="string">'x'</span>)	sec += c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可解性判断   用求逆序对来判断奇偶性</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sec[i] &gt; sec[j])	cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"unsolvable"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; bfs(start) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>BFS</tag>
        <tag>A*</tag>
      </tags>
  </entry>
</search>
